{
    "version": "https://jsonfeed.org/version/1",
    "title": "ClaRn'S BLOG • All posts by \"编译原理\" tag",
    "description": "当你在浪费时间的事情里获得了快乐，那就不是在浪费时间。 ——罗素",
    "home_page_url": "https://iyiyiyiyi.github.io",
    "items": [
        {
            "id": "https://iyiyiyiyi.github.io/post/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%80%83%E7%82%B9.html",
            "url": "https://iyiyiyiyi.github.io/post/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%80%83%E7%82%B9.html",
            "title": "编译原理考点",
            "date_published": "2023-03-15T12:38:09.000Z",
            "content_html": "<h2 id=\"编译原理作业\"><a class=\"markdownIt-Anchor\" href=\"#编译原理作业\"></a> 编译原理作业：</h2>\n<ul>\n<li><a href=\"/static-sites/dfa\">正则表达式生成NFA/DFA</a></li>\n<li><a href=\"/static-sites/ll1\">LL1 词法分析</a></li>\n<li><a href=\"/static-sites/lr\">LR 词法分析</a></li>\n</ul>\n<h2 id=\"编译程序的功能组织结构图\"><a class=\"markdownIt-Anchor\" href=\"#编译程序的功能组织结构图\"></a> 编译程序的功能组织结构图</h2>\n<ul>\n<li>‘词法分析器→语法分析器→语义分析器→中间代码生成器→代码优化器→目标代码’</li>\n<li>语法分析树和抽象语法树不是一个玩意儿(问题不大)</li>\n<li>词法分析\n<ul>\n<li>调度场算法\n<ul>\n<li><img src=\"./gallery/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95.png\" alt=\"调度场算法图示\" /></li>\n<li>使用栈针对不同运算符的优先级进行处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Chomsky四型文法\n<ul>\n<li>0型文法\n<ul>\n<li>无限制文法/短语结构文法\n<ul>\n<li>设G=（VN，VT，P，S），如果它的每个产生式α→β是这样一种结构：α∈(VN∪VT)*且至少含有一个非终结符，而 β∈(VN∪VT)*，则G是一个0型文法。0型文法也称短语文法。一个非常重要的理论结果是：0型文法的能力相当于图灵机(Turing)。或者说，任 何0型文语言都是递归可枚举的，反之，递归可枚举集必定是一个0型语言。0型文法是这几类文法中，限制最少的一个。0型文法是其它类型文法的母集。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>1型文法\n<ul>\n<li>上下文有关文法\n<ul>\n<li>1型文法也叫上下文有关文法，此文法对应于线性有界自动机。它是在0型文法的基础上每一个α→β,都有|β|&gt;=|α|。这里的|β|表示的是β的长度。</li>\n<li>注意：虽然要求|β|&gt;=|α|，但有一特例：α→ε也满足1型文法。</li>\n<li>如有A-&gt;Ba则|β|=2,|α|=1符合1型文法要求。反之,如aA-&gt;a，则不符合1型文法。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2型文法\n<ul>\n<li>上下文无关文法\n<ul>\n<li>在1型文法的基础上，每一个α→β都有α是非终结符。</li>\n<li>如A-&gt;Ba,符合2型文法要求。</li>\n<li>如Ab-&gt;Bab虽然符合1型文法要求,但不符合2型文法要求，因为其α=Ab，而Ab不是一个非终结符。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>3型文法\n<ul>\n<li>正则文法\n<ul>\n<li>对应有限状态自动机。</li>\n<li>在2型文法的基础上满足:A→α|αB（右线性）或A→α|Bα（左线性）。</li>\n<li>如有：A-&gt;a,A-&gt;aB,B-&gt;a,B-&gt;cB，则符合3型文法的要求。</li>\n<li>但如果推导 为:A-&gt;ab,A-&gt;aB,B-&gt;a,B-&gt;cB或推导 为:A-&gt;a,A-&gt;Ba,B-&gt;a,B-&gt;cB则不符合3型方法的要求了。</li>\n<li>具体的说，例子 A-&gt;ab,A-&gt;aB,B-&gt;a,B-&gt;cB中的A-&gt;ab不符合3型文法的定义,如果把后面的ab,改成“一个非终结符＋一个终结符”的形式（即为aB）就对了。例子A-&gt;a,A-&gt;Ba,B-&gt;a,B-&gt;cB中如果把B-&gt;cB改为 B-&gt;Bc的形式就对了,<strong>因为A→α|αB（右线性）和A→α|Bα（左线性）两套规则不能同时出现在一个语法中,只能完全满足其中的一个,才能算 3型文法。</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>正则表达式\n<ul>\n<li>| ：或</li>\n<li>* ：匹配0或无限个</li>\n<li>· ：连接</li>\n<li>优先级：*、·、|</li>\n<li>例如：\n<ul>\n<li>令 ∑ = {a, b}，则</li>\n<li>L(a|b) = L(a)∪L(b) ={a}∪{b} = {a, b}</li>\n<li>L((a|b)(a|b)) = L(a|b) L(a|b)={a, b}{a, b}= { aa, ab, ba, bb }</li>\n<li>L(a*) = (L(a))*= {a}*= { ε, a, aa, aaa, . . . }</li>\n<li>L((a|b)*) = (L(a|b))* = {a, b}*= { ε, a, b, aa, ab, ba, bb, aaa, . . .}</li>\n<li>L(a|a*b) = { a, b, ab, aab, aaab, . . .}</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"有穷自动机fa\"><a class=\"markdownIt-Anchor\" href=\"#有穷自动机fa\"></a> 有穷自动机(FA)</h2>\n<ul>\n<li>具有有穷个状态数\n<ul>\n<li>最长子串匹配原则：输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配。</li>\n</ul>\n</li>\n<li>NFA(非确定的FA)\n<ul>\n<li>NFA是不唯一的，但其对应的DFA是唯一的</li>\n<li>ε对应的NFA <img src=\"/gallery/NFA0.png\" alt=\"\" /></li>\n<li>r = r1r2对应的NFA <img src=\"/gallery/NFA1.png\" alt=\"\" /></li>\n<li>r = r1|r2 对应的NFA <img src=\"/gallery/NFA2.png\" alt=\"\" /></li>\n<li>r = (r1)*对应的NFA <img src=\"/gallery/NFA3.png\" alt=\"\" /></li>\n</ul>\n</li>\n<li>DFA(确定的FA)\n<ul>\n<li>DFA每个状态都是一个由NFA状态构成的集合，也就是NFA状态集合的一个子集。例如NFA中状态A可以经由a边到达状态A、B，则DFA中状态A可经由a边到达状态 {A,B} ，这里 {A,B}集合是一个状态。</li>\n<li>NFA→DFA：初始状态ε闭包T，求出后遍历终结符，对每个move(T,a)求ε闭包，求出的闭包为新的状态U，a即当前终结符，意思是T通过a到达U，将U换为T继续执行，直到没有新的U出现。</li>\n<li>如图所示 <code>r=aa*bb*cc*</code> 的无ε边的NFA到DFA的转换：\n<ol>\n<li>无ε边的NFA到DFA的转换 <img src=\"/gallery/NoENFATODFA.png\" alt=\"无ε边的NFA到DFA的转换\" /></li>\n<li>NFA状态转换表 <img src=\"/gallery/NoENFATODFA1.png\" alt=\"NFA状态转换表\" /></li>\n<li>转换后的DFA <img src=\"/gallery/NoENFATODFA2.png\" alt=\"转换后的DFA\" /></li>\n</ol>\n</li>\n<li>如图所示为带ε边的NFA到DFA的转换 <img src=\"/gallery/ENFATODFA.png\" alt=\"带有ε边的NFA到DFA的转换\" /></li>\n</ul>\n</li>\n<li>DFA最小化：\n<ul>\n<li>状态合并：将所有状态划分为终结状态和非终结状态，并将终结状态和非终结状态进行合并，合并规则为:二者同为终结状态或非终结状态，且通过指定输入符号可以到达的状态相同。</li>\n<li>ε-闭包(ε-closure)\n<ul>\n<li>ε-closure(s)：能够从NFA状态s开始只通过ε转换到达的NFA状态集合</li>\n<li>ε-closure(T)：能够从T中的某个NFA状态s开始，只通过ε转换到达的NFA状态集合</li>\n<li>move(T, a)：能够从T中的某个状态s出发通过标号为a的转换到达的NFA状态的集合</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"上下文无关文法\"><a class=\"markdownIt-Anchor\" href=\"#上下文无关文法\"></a> 上下文无关文法</h2>\n<ul>\n<li>二义性文法判断\n<ul>\n<li>能通过不同分析顺序生成两个分析树的文法称为二义性文法</li>\n<li>消除二义性：不修改文法，指定正确的分析树；或修改文法(指定优先级、结合性)</li>\n</ul>\n</li>\n<li>短语、简单短句和句柄判断\n<ul>\n<li>短语：每颗子树的叶子</li>\n<li>简单短语：每颗简单子树(仅有叶子结点没有根节点)的叶子</li>\n<li>句柄：最左简单子树的叶子(最左边的那个简单子树)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"自顶向下语法分析-最左推导既总是选择每个句型的最左非终结符进行替换\"><a class=\"markdownIt-Anchor\" href=\"#自顶向下语法分析-最左推导既总是选择每个句型的最左非终结符进行替换\"></a> 自顶向下语法分析 （最左推导：既总是选择每个句型的最左非终结符进行替换）</h2>\n<ul>\n<li>判定：产生式A → α | β 满足下面的条件：\n<ul>\n<li>如果α 和β均不能推导出ε ，则FIRST (α)∩FIRST (β) =Φ(空集)</li>\n<li>α 和β至多有一个能推导出ε</li>\n<li>如果 β →* ε，则FIRST (α)∩FOLLOW(A) =Φ; 如果 α →* ε，则FIRST (β)∩FOLLOW(A) =Φ;</li>\n</ul>\n</li>\n<li>消除左递归：(A → A α1 | A α2 | β1 | β2)→(A → β1 A′ | β2 A′;A′ → α1 A′ | α2 A′ | ε)</li>\n<li>间接左递归：将间接左递归文法的定义代入得到直接左递归，再消除</li>\n<li>提取左因子：(S → aAd | aBe)→(S → a S’;S’ → Ad | Be)</li>\n<li>First、Follow\n<ul>\n<li>First：可以从X推导出的所有串首终结符构成的集合;可以存在ε</li>\n<li>Follow：可能在某个句型中紧跟在A后边的终结符a的集合；如果A是某个句型的的最右符号，则将结束符“<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi mathvariant=\"normal\">”</mi><mi mathvariant=\"normal\">添</mi><mi mathvariant=\"normal\">加</mi><mi mathvariant=\"normal\">到</mi><mi>F</mi><mi>O</mi><mi>L</mi><mi>L</mi><mi>O</mi><mi>W</mi><mo stretchy=\"false\">(</mo><mi>A</mi><mo stretchy=\"false\">)</mo><mi mathvariant=\"normal\">中</mi><mi mathvariant=\"normal\">；</mi><mi mathvariant=\"normal\">如</mi><mi mathvariant=\"normal\">果</mi><mi mathvariant=\"normal\">是</mi><mi mathvariant=\"normal\">起</mi><mi mathvariant=\"normal\">始</mi><mi mathvariant=\"normal\">的</mi><mi mathvariant=\"normal\">第</mi><mi mathvariant=\"normal\">一</mi><mi mathvariant=\"normal\">句</mi><mi mathvariant=\"normal\">，</mi><mi mathvariant=\"normal\">则</mi><mi mathvariant=\"normal\">添</mi><mi mathvariant=\"normal\">加</mi><mi mathvariant=\"normal\">“</mi></mrow><annotation encoding=\"application/x-tex\">”添加到FOLLOW(A)中；如果是起始的第一句，则添加“</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">”</span><span class=\"mord cjk_fallback\">添</span><span class=\"mord cjk_fallback\">加</span><span class=\"mord cjk_fallback\">到</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathdefault\">L</span><span class=\"mord mathdefault\">L</span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">W</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">A</span><span class=\"mclose\">)</span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">；</span><span class=\"mord cjk_fallback\">如</span><span class=\"mord cjk_fallback\">果</span><span class=\"mord cjk_fallback\">是</span><span class=\"mord cjk_fallback\">起</span><span class=\"mord cjk_fallback\">始</span><span class=\"mord cjk_fallback\">的</span><span class=\"mord cjk_fallback\">第</span><span class=\"mord cjk_fallback\">一</span><span class=\"mord cjk_fallback\">句</span><span class=\"mord cjk_fallback\">，</span><span class=\"mord cjk_fallback\">则</span><span class=\"mord cjk_fallback\">添</span><span class=\"mord cjk_fallback\">加</span><span class=\"mord\">“</span></span></span></span>”</li>\n</ul>\n</li>\n<li>LL(1)分析表\n<ul>\n<li>Select：将每条文法拆分为拓广文法，若该条文法A的First为ε，则Select(A)=Follow(A)，否则Select(A)=First(A)</li>\n<li>通过Select集合可以看到不同拓广文法产生式对应的终结符，使用其构建终结符与非终结符相对应的文法分析表即可。(考试记得写编号)</li>\n</ul>\n</li>\n<li>LL(1)分析过程\n<ul>\n<li>分析栈：第一次为E，之后根据输入队列进行获取输入符号，通过输入符号和栈顶非终结符查找分析表进行文法推导，若为终结符则进行出栈匹配操作。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"自底向上语法分析-归约\"><a class=\"markdownIt-Anchor\" href=\"#自底向上语法分析-归约\"></a> 自底向上语法分析 （归约）</h2>\n<ul>\n<li>拓广文法\n<ul>\n<li>就是全写出来，然后在最前面加个S’→S，有手就行</li>\n</ul>\n</li>\n<li>LR(0)项目：\n<ul>\n<li>加上小圆点的状态示意句柄</li>\n</ul>\n</li>\n<li>LR(0)识别活前缀状态机\n<ul>\n<li>从第一条增广文法开始往下，列出所有可以推导出的项目，然后写出每个项目移进之后的状态，直到小圆点到了最后再也推导不出来新的状态，就是规约状态。</li>\n</ul>\n</li>\n<li>LR方法判断过程</li>\n<li>LR(0)分析表、SLR(1)分析表\n<ul>\n<li>LR(0)分析表：\n<ul>\n<li>分为两部分：Action和GOTO\n<ul>\n<li>ACTION：移进项目</li>\n<li>GOTO：跳转到文法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>SLR(1)分析表：\n<ul>\n<li>如果下一个输入符号a属于移进项目，则移进；若a属于某个规约项目的Follow，则使用该规约项目进行规约</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>LR分析过程</li>\n<li>LR(1)识别活前缀状态机</li>\n<li>LALR(1)判断</li>\n<li>LALR(1)识别活前缀状态机</li>\n<li>LR(1)分析表、LALR(1)分析表\n<ul>\n<li>如果除了展望符外，两个LR(1)项目集是相同的，则称这两个LR(1)项目集是同心的</li>\n<li>LALR(1)状态机即合并同心项后的LR(1)状态机</li>\n</ul>\n</li>\n<li>LR分析过程</li>\n</ul>\n<h2 id=\"语义分析\"><a class=\"markdownIt-Anchor\" href=\"#语义分析\"></a> 语义分析</h2>\n<ul>\n<li>依赖图(拓扑排序)语义分析</li>\n<li>S属性文法语义分析</li>\n<li>L属性文法语义分析</li>\n</ul>\n<h2 id=\"中间代码三地址码的四元式-三元式表示\"><a class=\"markdownIt-Anchor\" href=\"#中间代码三地址码的四元式-三元式表示\"></a> 中间代码三地址码的四元式、三元式表示</h2>\n<ul>\n<li>四元式：(op,arg1,arg2,return)</li>\n<li>三元式：x=(t+r)*y → t1=t+r;t2=t1*r;x=t2;</li>\n</ul>\n<h2 id=\"基于基本块的dag的中间代码优化\"><a class=\"markdownIt-Anchor\" href=\"#基于基本块的dag的中间代码优化\"></a> 基于基本块的DAG的中间代码优化</h2>\n<ul>\n<li>基本块：程序中一段顺序执行的语句序列</li>\n<li>通过每一条三地址码或四元式构建节点，将相关的节点相连，若节点内容一样，在右边加上名字，节点下方为常量值或运算符。</li>\n</ul>\n",
            "tags": [
                "Review",
                "编译原理"
            ]
        }
    ]
}