<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://iyiyiyiyi.github.io</id>
    <title>ClaRn&#39;S BLOG • Posts by &#34;编译原理&#34; tag</title>
    <link href="https://iyiyiyiyi.github.io" />
    <updated>2023-03-15T12:38:09.000Z</updated>
    <category term="Android" />
    <category term="压缩算法" />
    <category term="作业" />
    <category term="模式识别" />
    <category term="机器学习" />
    <category term="生物信息学" />
    <category term="算法" />
    <category term="动态规划" />
    <category term="数据库" />
    <category term="Review" />
    <category term="图像处理" />
    <category term="OpenCV" />
    <category term="操作系统" />
    <category term="编译原理" />
    <category term="软件工程" />
    <category term="数据结构" />
    <category term="人工智能" />
    <entry>
        <id>https://iyiyiyiyi.github.io/post/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%80%83%E7%82%B9.html</id>
        <title>编译原理考点</title>
        <link rel="alternate" href="https://iyiyiyiyi.github.io/post/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%80%83%E7%82%B9.html"/>
        <content type="html">&lt;h2 id=&#34;编译原理作业&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#编译原理作业&#34;&gt;&lt;/a&gt; 编译原理作业：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/static-sites/dfa&#34;&gt;正则表达式生成NFA/DFA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/static-sites/ll1&#34;&gt;LL1 词法分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/static-sites/lr&#34;&gt;LR 词法分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译程序的功能组织结构图&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#编译程序的功能组织结构图&#34;&gt;&lt;/a&gt; 编译程序的功能组织结构图&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;‘词法分析器→语法分析器→语义分析器→中间代码生成器→代码优化器→目标代码’&lt;/li&gt;
&lt;li&gt;语法分析树和抽象语法树不是一个玩意儿(问题不大)&lt;/li&gt;
&lt;li&gt;词法分析
&lt;ul&gt;
&lt;li&gt;调度场算法
&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;./gallery/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95.png&#34; alt=&#34;调度场算法图示&#34; /&gt;&lt;/li&gt;
&lt;li&gt;使用栈针对不同运算符的优先级进行处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Chomsky四型文法
&lt;ul&gt;
&lt;li&gt;0型文法
&lt;ul&gt;
&lt;li&gt;无限制文法/短语结构文法
&lt;ul&gt;
&lt;li&gt;设G=（VN，VT，P，S），如果它的每个产生式α→β是这样一种结构：α∈(VN∪VT)*且至少含有一个非终结符，而 β∈(VN∪VT)*，则G是一个0型文法。0型文法也称短语文法。一个非常重要的理论结果是：0型文法的能力相当于图灵机(Turing)。或者说，任 何0型文语言都是递归可枚举的，反之，递归可枚举集必定是一个0型语言。0型文法是这几类文法中，限制最少的一个。0型文法是其它类型文法的母集。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1型文法
&lt;ul&gt;
&lt;li&gt;上下文有关文法
&lt;ul&gt;
&lt;li&gt;1型文法也叫上下文有关文法，此文法对应于线性有界自动机。它是在0型文法的基础上每一个α→β,都有|β|&amp;gt;=|α|。这里的|β|表示的是β的长度。&lt;/li&gt;
&lt;li&gt;注意：虽然要求|β|&amp;gt;=|α|，但有一特例：α→ε也满足1型文法。&lt;/li&gt;
&lt;li&gt;如有A-&amp;gt;Ba则|β|=2,|α|=1符合1型文法要求。反之,如aA-&amp;gt;a，则不符合1型文法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2型文法
&lt;ul&gt;
&lt;li&gt;上下文无关文法
&lt;ul&gt;
&lt;li&gt;在1型文法的基础上，每一个α→β都有α是非终结符。&lt;/li&gt;
&lt;li&gt;如A-&amp;gt;Ba,符合2型文法要求。&lt;/li&gt;
&lt;li&gt;如Ab-&amp;gt;Bab虽然符合1型文法要求,但不符合2型文法要求，因为其α=Ab，而Ab不是一个非终结符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3型文法
&lt;ul&gt;
&lt;li&gt;正则文法
&lt;ul&gt;
&lt;li&gt;对应有限状态自动机。&lt;/li&gt;
&lt;li&gt;在2型文法的基础上满足:A→α|αB（右线性）或A→α|Bα（左线性）。&lt;/li&gt;
&lt;li&gt;如有：A-&amp;gt;a,A-&amp;gt;aB,B-&amp;gt;a,B-&amp;gt;cB，则符合3型文法的要求。&lt;/li&gt;
&lt;li&gt;但如果推导 为:A-&amp;gt;ab,A-&amp;gt;aB,B-&amp;gt;a,B-&amp;gt;cB或推导 为:A-&amp;gt;a,A-&amp;gt;Ba,B-&amp;gt;a,B-&amp;gt;cB则不符合3型方法的要求了。&lt;/li&gt;
&lt;li&gt;具体的说，例子 A-&amp;gt;ab,A-&amp;gt;aB,B-&amp;gt;a,B-&amp;gt;cB中的A-&amp;gt;ab不符合3型文法的定义,如果把后面的ab,改成“一个非终结符＋一个终结符”的形式（即为aB）就对了。例子A-&amp;gt;a,A-&amp;gt;Ba,B-&amp;gt;a,B-&amp;gt;cB中如果把B-&amp;gt;cB改为 B-&amp;gt;Bc的形式就对了,&lt;strong&gt;因为A→α|αB（右线性）和A→α|Bα（左线性）两套规则不能同时出现在一个语法中,只能完全满足其中的一个,才能算 3型文法。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;正则表达式
&lt;ul&gt;
&lt;li&gt;| ：或&lt;/li&gt;
&lt;li&gt;* ：匹配0或无限个&lt;/li&gt;
&lt;li&gt;· ：连接&lt;/li&gt;
&lt;li&gt;优先级：*、·、|&lt;/li&gt;
&lt;li&gt;例如：
&lt;ul&gt;
&lt;li&gt;令 ∑ = {a, b}，则&lt;/li&gt;
&lt;li&gt;L(a|b) = L(a)∪L(b) ={a}∪{b} = {a, b}&lt;/li&gt;
&lt;li&gt;L((a|b)(a|b)) = L(a|b) L(a|b)={a, b}{a, b}= { aa, ab, ba, bb }&lt;/li&gt;
&lt;li&gt;L(a*) = (L(a))*= {a}*= { ε, a, aa, aaa, . . . }&lt;/li&gt;
&lt;li&gt;L((a|b)*) = (L(a|b))* = {a, b}*= { ε, a, b, aa, ab, ba, bb, aaa, . . .}&lt;/li&gt;
&lt;li&gt;L(a|a*b) = { a, b, ab, aab, aaab, . . .}&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;有穷自动机fa&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#有穷自动机fa&#34;&gt;&lt;/a&gt; 有穷自动机(FA)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;具有有穷个状态数
&lt;ul&gt;
&lt;li&gt;最长子串匹配原则：输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NFA(非确定的FA)
&lt;ul&gt;
&lt;li&gt;NFA是不唯一的，但其对应的DFA是唯一的&lt;/li&gt;
&lt;li&gt;ε对应的NFA &lt;img src=&#34;/gallery/NFA0.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;r = r1r2对应的NFA &lt;img src=&#34;/gallery/NFA1.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;r = r1|r2 对应的NFA &lt;img src=&#34;/gallery/NFA2.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;r = (r1)*对应的NFA &lt;img src=&#34;/gallery/NFA3.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DFA(确定的FA)
&lt;ul&gt;
&lt;li&gt;DFA每个状态都是一个由NFA状态构成的集合，也就是NFA状态集合的一个子集。例如NFA中状态A可以经由a边到达状态A、B，则DFA中状态A可经由a边到达状态 {A,B} ，这里 {A,B}集合是一个状态。&lt;/li&gt;
&lt;li&gt;NFA→DFA：初始状态ε闭包T，求出后遍历终结符，对每个move(T,a)求ε闭包，求出的闭包为新的状态U，a即当前终结符，意思是T通过a到达U，将U换为T继续执行，直到没有新的U出现。&lt;/li&gt;
&lt;li&gt;如图所示 &lt;code&gt;r=aa*bb*cc*&lt;/code&gt; 的无ε边的NFA到DFA的转换：
&lt;ol&gt;
&lt;li&gt;无ε边的NFA到DFA的转换 &lt;img src=&#34;/gallery/NoENFATODFA.png&#34; alt=&#34;无ε边的NFA到DFA的转换&#34; /&gt;&lt;/li&gt;
&lt;li&gt;NFA状态转换表 &lt;img src=&#34;/gallery/NoENFATODFA1.png&#34; alt=&#34;NFA状态转换表&#34; /&gt;&lt;/li&gt;
&lt;li&gt;转换后的DFA &lt;img src=&#34;/gallery/NoENFATODFA2.png&#34; alt=&#34;转换后的DFA&#34; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如图所示为带ε边的NFA到DFA的转换 &lt;img src=&#34;/gallery/ENFATODFA.png&#34; alt=&#34;带有ε边的NFA到DFA的转换&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DFA最小化：
&lt;ul&gt;
&lt;li&gt;状态合并：将所有状态划分为终结状态和非终结状态，并将终结状态和非终结状态进行合并，合并规则为:二者同为终结状态或非终结状态，且通过指定输入符号可以到达的状态相同。&lt;/li&gt;
&lt;li&gt;ε-闭包(ε-closure)
&lt;ul&gt;
&lt;li&gt;ε-closure(s)：能够从NFA状态s开始只通过ε转换到达的NFA状态集合&lt;/li&gt;
&lt;li&gt;ε-closure(T)：能够从T中的某个NFA状态s开始，只通过ε转换到达的NFA状态集合&lt;/li&gt;
&lt;li&gt;move(T, a)：能够从T中的某个状态s出发通过标号为a的转换到达的NFA状态的集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;上下文无关文法&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#上下文无关文法&#34;&gt;&lt;/a&gt; 上下文无关文法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;二义性文法判断
&lt;ul&gt;
&lt;li&gt;能通过不同分析顺序生成两个分析树的文法称为二义性文法&lt;/li&gt;
&lt;li&gt;消除二义性：不修改文法，指定正确的分析树；或修改文法(指定优先级、结合性)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;短语、简单短句和句柄判断
&lt;ul&gt;
&lt;li&gt;短语：每颗子树的叶子&lt;/li&gt;
&lt;li&gt;简单短语：每颗简单子树(仅有叶子结点没有根节点)的叶子&lt;/li&gt;
&lt;li&gt;句柄：最左简单子树的叶子(最左边的那个简单子树)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;自顶向下语法分析-最左推导既总是选择每个句型的最左非终结符进行替换&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#自顶向下语法分析-最左推导既总是选择每个句型的最左非终结符进行替换&#34;&gt;&lt;/a&gt; 自顶向下语法分析 （最左推导：既总是选择每个句型的最左非终结符进行替换）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;判定：产生式A → α | β 满足下面的条件：
&lt;ul&gt;
&lt;li&gt;如果α 和β均不能推导出ε ，则FIRST (α)∩FIRST (β) =Φ(空集)&lt;/li&gt;
&lt;li&gt;α 和β至多有一个能推导出ε&lt;/li&gt;
&lt;li&gt;如果 β →* ε，则FIRST (α)∩FOLLOW(A) =Φ; 如果 α →* ε，则FIRST (β)∩FOLLOW(A) =Φ;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消除左递归：(A → A α1 | A α2 | β1 | β2)→(A → β1 A′ | β2 A′;A′ → α1 A′ | α2 A′ | ε)&lt;/li&gt;
&lt;li&gt;间接左递归：将间接左递归文法的定义代入得到直接左递归，再消除&lt;/li&gt;
&lt;li&gt;提取左因子：(S → aAd | aBe)→(S → a S’;S’ → Ad | Be)&lt;/li&gt;
&lt;li&gt;First、Follow
&lt;ul&gt;
&lt;li&gt;First：可以从X推导出的所有串首终结符构成的集合;可以存在ε&lt;/li&gt;
&lt;li&gt;Follow：可能在某个句型中紧跟在A后边的终结符a的集合；如果A是某个句型的的最右符号，则将结束符“&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;”&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;添&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;加&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;到&lt;/mi&gt;&lt;mi&gt;F&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mi&gt;O&lt;/mi&gt;&lt;mi&gt;W&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;(&lt;/mo&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo stretchy=&#34;false&#34;&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;；&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;如&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;果&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;起&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;始&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;第&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;句&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;则&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;添&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;加&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;“&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;”添加到FOLLOW(A)中；如果是起始的第一句，则添加“&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;”&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;添&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;加&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;到&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;F&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;O&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;W&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;；&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;如&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;果&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;起&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;始&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;第&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;句&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;则&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;添&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;加&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;“&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LL(1)分析表
&lt;ul&gt;
&lt;li&gt;Select：将每条文法拆分为拓广文法，若该条文法A的First为ε，则Select(A)=Follow(A)，否则Select(A)=First(A)&lt;/li&gt;
&lt;li&gt;通过Select集合可以看到不同拓广文法产生式对应的终结符，使用其构建终结符与非终结符相对应的文法分析表即可。(考试记得写编号)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LL(1)分析过程
&lt;ul&gt;
&lt;li&gt;分析栈：第一次为E，之后根据输入队列进行获取输入符号，通过输入符号和栈顶非终结符查找分析表进行文法推导，若为终结符则进行出栈匹配操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;自底向上语法分析-归约&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#自底向上语法分析-归约&#34;&gt;&lt;/a&gt; 自底向上语法分析 （归约）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;拓广文法
&lt;ul&gt;
&lt;li&gt;就是全写出来，然后在最前面加个S’→S，有手就行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LR(0)项目：
&lt;ul&gt;
&lt;li&gt;加上小圆点的状态示意句柄&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LR(0)识别活前缀状态机
&lt;ul&gt;
&lt;li&gt;从第一条增广文法开始往下，列出所有可以推导出的项目，然后写出每个项目移进之后的状态，直到小圆点到了最后再也推导不出来新的状态，就是规约状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LR方法判断过程&lt;/li&gt;
&lt;li&gt;LR(0)分析表、SLR(1)分析表
&lt;ul&gt;
&lt;li&gt;LR(0)分析表：
&lt;ul&gt;
&lt;li&gt;分为两部分：Action和GOTO
&lt;ul&gt;
&lt;li&gt;ACTION：移进项目&lt;/li&gt;
&lt;li&gt;GOTO：跳转到文法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SLR(1)分析表：
&lt;ul&gt;
&lt;li&gt;如果下一个输入符号a属于移进项目，则移进；若a属于某个规约项目的Follow，则使用该规约项目进行规约&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LR分析过程&lt;/li&gt;
&lt;li&gt;LR(1)识别活前缀状态机&lt;/li&gt;
&lt;li&gt;LALR(1)判断&lt;/li&gt;
&lt;li&gt;LALR(1)识别活前缀状态机&lt;/li&gt;
&lt;li&gt;LR(1)分析表、LALR(1)分析表
&lt;ul&gt;
&lt;li&gt;如果除了展望符外，两个LR(1)项目集是相同的，则称这两个LR(1)项目集是同心的&lt;/li&gt;
&lt;li&gt;LALR(1)状态机即合并同心项后的LR(1)状态机&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LR分析过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;语义分析&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#语义分析&#34;&gt;&lt;/a&gt; 语义分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;依赖图(拓扑排序)语义分析&lt;/li&gt;
&lt;li&gt;S属性文法语义分析&lt;/li&gt;
&lt;li&gt;L属性文法语义分析&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;中间代码三地址码的四元式-三元式表示&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#中间代码三地址码的四元式-三元式表示&#34;&gt;&lt;/a&gt; 中间代码三地址码的四元式、三元式表示&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;四元式：(op,arg1,arg2,return)&lt;/li&gt;
&lt;li&gt;三元式：x=(t+r)*y → t1=t+r;t2=t1*r;x=t2;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基于基本块的dag的中间代码优化&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#基于基本块的dag的中间代码优化&#34;&gt;&lt;/a&gt; 基于基本块的DAG的中间代码优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基本块：程序中一段顺序执行的语句序列&lt;/li&gt;
&lt;li&gt;通过每一条三地址码或四元式构建节点，将相关的节点相连，若节点内容一样，在右边加上名字，节点下方为常量值或运算符。&lt;/li&gt;
&lt;/ul&gt;
</content>
        <category term="Review" />
        <category term="编译原理" />
        <updated>2023-03-15T12:38:09.000Z</updated>
    </entry>
</feed>
