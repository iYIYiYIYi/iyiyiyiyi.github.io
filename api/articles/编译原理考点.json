{"title":"编译原理考点","uid":"fba5abef53d9d5ea6aea61fb0369866c","slug":"编译原理考点","date":"2023-03-15T12:38:09.000Z","updated":"2023-12-06T14:52:33.108Z","comments":true,"path":"api/articles/编译原理考点.json","keywords":"记录, 学习, ClaRnS","cover":"/gallery/os.jpg","content":"<h2 id=\"编译原理作业：\"><a href=\"#编译原理作业：\" class=\"headerlink\" title=\"编译原理作业：\"></a>编译原理作业：</h2><ul>\n<li><a href=\"/static-sites/dfa\">正则表达式生成NFA&#x2F;DFA</a></li>\n<li><a href=\"/static-sites/ll1\">LL1 词法分析</a></li>\n<li><a href=\"/static-sites/lr\">LR 词法分析</a></li>\n</ul>\n<h2 id=\"编译程序的功能组织结构图\"><a href=\"#编译程序的功能组织结构图\" class=\"headerlink\" title=\"编译程序的功能组织结构图\"></a>编译程序的功能组织结构图</h2><ul>\n<li>‘词法分析器→语法分析器→语义分析器→中间代码生成器→代码优化器→目标代码’</li>\n<li>语法分析树和抽象语法树不是一个玩意儿(问题不大)</li>\n<li>词法分析<ul>\n<li>调度场算法<ul>\n<li><img src=\"/./gallery/%E8%B0%83%E5%BA%A6%E5%9C%BA%E7%AE%97%E6%B3%95.png\" alt=\"调度场算法图示\"></li>\n<li>使用栈针对不同运算符的优先级进行处理</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Chomsky四型文法<ul>\n<li>0型文法<ul>\n<li>无限制文法&#x2F;短语结构文法<ul>\n<li>设G&#x3D;（VN，VT，P，S），如果它的每个产生式α→β是这样一种结构：α∈(VN∪VT)*且至少含有一个非终结符，而 β∈(VN∪VT)*，则G是一个0型文法。0型文法也称短语文法。一个非常重要的理论结果是：0型文法的能力相当于图灵机(Turing)。或者说，任 何0型文语言都是递归可枚举的，反之，递归可枚举集必定是一个0型语言。0型文法是这几类文法中，限制最少的一个。0型文法是其它类型文法的母集。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>1型文法<ul>\n<li>上下文有关文法<ul>\n<li>1型文法也叫上下文有关文法，此文法对应于线性有界自动机。它是在0型文法的基础上每一个α→β,都有|β|&gt;&#x3D;|α|。这里的|β|表示的是β的长度。</li>\n<li>注意：虽然要求|β|&gt;&#x3D;|α|，但有一特例：α→ε也满足1型文法。</li>\n<li>如有A-&gt;Ba则|β|&#x3D;2,|α|&#x3D;1符合1型文法要求。反之,如aA-&gt;a，则不符合1型文法。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>2型文法<ul>\n<li>上下文无关文法<ul>\n<li>在1型文法的基础上，每一个α→β都有α是非终结符。</li>\n<li>如A-&gt;Ba,符合2型文法要求。</li>\n<li>如Ab-&gt;Bab虽然符合1型文法要求,但不符合2型文法要求，因为其α&#x3D;Ab，而Ab不是一个非终结符。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>3型文法<ul>\n<li>正则文法<ul>\n<li>对应有限状态自动机。</li>\n<li>在2型文法的基础上满足:A→α|αB（右线性）或A→α|Bα（左线性）。</li>\n<li>如有：A-&gt;a,A-&gt;aB,B-&gt;a,B-&gt;cB，则符合3型文法的要求。</li>\n<li>但如果推导 为:A-&gt;ab,A-&gt;aB,B-&gt;a,B-&gt;cB或推导 为:A-&gt;a,A-&gt;Ba,B-&gt;a,B-&gt;cB则不符合3型方法的要求了。</li>\n<li>具体的说，例子 A-&gt;ab,A-&gt;aB,B-&gt;a,B-&gt;cB中的A-&gt;ab不符合3型文法的定义,如果把后面的ab,改成“一个非终结符＋一个终结符”的形式（即为aB）就对了。例子A-&gt;a,A-&gt;Ba,B-&gt;a,B-&gt;cB中如果把B-&gt;cB改为 B-&gt;Bc的形式就对了,<strong>因为A→α|αB（右线性）和A→α|Bα（左线性）两套规则不能同时出现在一个语法中,只能完全满足其中的一个,才能算 3型文法。</strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>正则表达式<ul>\n<li>| ：或</li>\n<li>* ：匹配0或无限个</li>\n<li>· ：连接</li>\n<li>优先级：*、·、|</li>\n<li>例如：<ul>\n<li>令 ∑ &#x3D; {a, b}，则</li>\n<li>L(a|b) &#x3D; L(a)∪L(b) &#x3D;{a}∪{b} &#x3D; {a, b}</li>\n<li>L((a|b)(a|b)) &#x3D; L(a|b) L(a|b)&#x3D;{a, b}{a, b}&#x3D; { aa, ab, ba, bb }</li>\n<li>L(a*) &#x3D; (L(a))*&#x3D; {a}*&#x3D; { ε, a, aa, aaa, . . . }</li>\n<li>L((a|b)*) &#x3D; (L(a|b))* &#x3D; {a, b}*&#x3D; { ε, a, b, aa, ab, ba, bb, aaa, . . .}</li>\n<li>L(a|a*b) &#x3D; { a, b, ab, aab, aaab, . . .}</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"有穷自动机-FA\"><a href=\"#有穷自动机-FA\" class=\"headerlink\" title=\"有穷自动机(FA)\"></a>有穷自动机(FA)</h2><ul>\n<li>具有有穷个状态数<ul>\n<li>最长子串匹配原则：输入串的多个前缀与一个或多个模式匹配时，总是选择最长的前缀进行匹配。</li>\n</ul>\n</li>\n<li>NFA(非确定的FA)<ul>\n<li>NFA是不唯一的，但其对应的DFA是唯一的</li>\n<li>ε对应的NFA <img src=\"/gallery/NFA0.png\"></li>\n<li>r &#x3D; r1r2对应的NFA <img src=\"/gallery/NFA1.png\"></li>\n<li>r &#x3D; r1|r2 对应的NFA <img src=\"/gallery/NFA2.png\"></li>\n<li>r &#x3D; (r1)*对应的NFA <img src=\"/gallery/NFA3.png\"></li>\n</ul>\n</li>\n<li>DFA(确定的FA)<ul>\n<li>DFA每个状态都是一个由NFA状态构成的集合，也就是NFA状态集合的一个子集。例如NFA中状态A可以经由a边到达状态A、B，则DFA中状态A可经由a边到达状态 {A,B} ，这里 {A,B}集合是一个状态。</li>\n<li>NFA→DFA：初始状态ε闭包T，求出后遍历终结符，对每个move(T,a)求ε闭包，求出的闭包为新的状态U，a即当前终结符，意思是T通过a到达U，将U换为T继续执行，直到没有新的U出现。</li>\n<li>如图所示 <code>r=aa*bb*cc*</code> 的无ε边的NFA到DFA的转换：<ol>\n<li>无ε边的NFA到DFA的转换 <img src=\"/gallery/NoENFATODFA.png\" alt=\"无ε边的NFA到DFA的转换\"></li>\n<li>NFA状态转换表 <img src=\"/gallery/NoENFATODFA1.png\" alt=\"NFA状态转换表\"></li>\n<li>转换后的DFA <img src=\"/gallery/NoENFATODFA2.png\" alt=\"转换后的DFA\"></li>\n</ol>\n</li>\n<li>如图所示为带ε边的NFA到DFA的转换 <img src=\"/gallery/ENFATODFA.png\" alt=\"带有ε边的NFA到DFA的转换\"></li>\n</ul>\n</li>\n<li>DFA最小化：<ul>\n<li>状态合并：将所有状态划分为终结状态和非终结状态，并将终结状态和非终结状态进行合并，合并规则为:二者同为终结状态或非终结状态，且通过指定输入符号可以到达的状态相同。</li>\n<li>ε-闭包(ε-closure)<ul>\n<li>ε-closure(s)：能够从NFA状态s开始只通过ε转换到达的NFA状态集合</li>\n<li>ε-closure(T)：能够从T中的某个NFA状态s开始，只通过ε转换到达的NFA状态集合</li>\n<li>move(T, a)：能够从T中的某个状态s出发通过标号为a的转换到达的NFA状态的集合</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"上下文无关文法\"><a href=\"#上下文无关文法\" class=\"headerlink\" title=\"上下文无关文法\"></a>上下文无关文法</h2><ul>\n<li>二义性文法判断<ul>\n<li>能通过不同分析顺序生成两个分析树的文法称为二义性文法</li>\n<li>消除二义性：不修改文法，指定正确的分析树；或修改文法(指定优先级、结合性)</li>\n</ul>\n</li>\n<li>短语、简单短句和句柄判断<ul>\n<li>短语：每颗子树的叶子</li>\n<li>简单短语：每颗简单子树(仅有叶子结点没有根节点)的叶子</li>\n<li>句柄：最左简单子树的叶子(最左边的那个简单子树)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"自顶向下语法分析-（最左推导：既总是选择每个句型的最左非终结符进行替换）\"><a href=\"#自顶向下语法分析-（最左推导：既总是选择每个句型的最左非终结符进行替换）\" class=\"headerlink\" title=\"自顶向下语法分析 （最左推导：既总是选择每个句型的最左非终结符进行替换）\"></a>自顶向下语法分析 （最左推导：既总是选择每个句型的最左非终结符进行替换）</h2><ul>\n<li>判定：产生式A → α | β 满足下面的条件：<ul>\n<li>如果α 和β均不能推导出ε ，则FIRST (α)∩FIRST (β) &#x3D;Φ(空集)</li>\n<li>α 和β至多有一个能推导出ε</li>\n<li>如果 β →* ε，则FIRST (α)∩FOLLOW(A) &#x3D;Φ; 如果 α →* ε，则FIRST (β)∩FOLLOW(A) &#x3D;Φ;</li>\n</ul>\n</li>\n<li>消除左递归：(A → A α1 | A α2 | β1 | β2)→(A → β1 A′ | β2 A′;A′ → α1 A′ | α2 A′ | ε)</li>\n<li>间接左递归：将间接左递归文法的定义代入得到直接左递归，再消除</li>\n<li>提取左因子：(S → aAd | aBe)→(S → a S’;S’ → Ad | Be)</li>\n<li>First、Follow<ul>\n<li>First：可以从X推导出的所有串首终结符构成的集合;可以存在ε</li>\n<li>Follow：可能在某个句型中紧跟在A后边的终结符a的集合；如果A是某个句型的的最右符号，则将结束符“$”添加到FOLLOW(A)中；如果是起始的第一句，则添加“$”</li>\n</ul>\n</li>\n<li>LL(1)分析表<ul>\n<li>Select：将每条文法拆分为拓广文法，若该条文法A的First为ε，则Select(A)&#x3D;Follow(A)，否则Select(A)&#x3D;First(A)</li>\n<li>通过Select集合可以看到不同拓广文法产生式对应的终结符，使用其构建终结符与非终结符相对应的文法分析表即可。(考试记得写编号)</li>\n</ul>\n</li>\n<li>LL(1)分析过程<ul>\n<li>分析栈：第一次为E，之后根据输入队列进行获取输入符号，通过输入符号和栈顶非终结符查找分析表进行文法推导，若为终结符则进行出栈匹配操作。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"自底向上语法分析-（归约）\"><a href=\"#自底向上语法分析-（归约）\" class=\"headerlink\" title=\"自底向上语法分析 （归约）\"></a>自底向上语法分析 （归约）</h2><ul>\n<li>拓广文法<ul>\n<li>就是全写出来，然后在最前面加个S’→S，有手就行</li>\n</ul>\n</li>\n<li>LR(0)项目：<ul>\n<li>加上小圆点的状态示意句柄</li>\n</ul>\n</li>\n<li>LR(0)识别活前缀状态机<ul>\n<li>从第一条增广文法开始往下，列出所有可以推导出的项目，然后写出每个项目移进之后的状态，直到小圆点到了最后再也推导不出来新的状态，就是规约状态。</li>\n</ul>\n</li>\n<li>LR方法判断过程</li>\n<li>LR(0)分析表、SLR(1)分析表<ul>\n<li>LR(0)分析表：<ul>\n<li>分为两部分：Action和GOTO<ul>\n<li>ACTION：移进项目</li>\n<li>GOTO：跳转到文法</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>SLR(1)分析表：<ul>\n<li>如果下一个输入符号a属于移进项目，则移进；若a属于某个规约项目的Follow，则使用该规约项目进行规约</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>LR分析过程</li>\n<li>LR(1)识别活前缀状态机</li>\n<li>LALR(1)判断</li>\n<li>LALR(1)识别活前缀状态机</li>\n<li>LR(1)分析表、LALR(1)分析表<ul>\n<li>如果除了展望符外，两个LR(1)项目集是相同的，则称这两个LR(1)项目集是同心的</li>\n<li>LALR(1)状态机即合并同心项后的LR(1)状态机</li>\n</ul>\n</li>\n<li>LR分析过程</li>\n</ul>\n<h2 id=\"语义分析\"><a href=\"#语义分析\" class=\"headerlink\" title=\"语义分析\"></a>语义分析</h2><ul>\n<li>依赖图(拓扑排序)语义分析</li>\n<li>S属性文法语义分析</li>\n<li>L属性文法语义分析</li>\n</ul>\n<h2 id=\"中间代码三地址码的四元式、三元式表示\"><a href=\"#中间代码三地址码的四元式、三元式表示\" class=\"headerlink\" title=\"中间代码三地址码的四元式、三元式表示\"></a>中间代码三地址码的四元式、三元式表示</h2><ul>\n<li>四元式：(op,arg1,arg2,return)</li>\n<li>三元式：x&#x3D;(t+r)*y → t1&#x3D;t+r;t2&#x3D;t1*r;x&#x3D;t2;</li>\n</ul>\n<h2 id=\"基于基本块的DAG的中间代码优化\"><a href=\"#基于基本块的DAG的中间代码优化\" class=\"headerlink\" title=\"基于基本块的DAG的中间代码优化\"></a>基于基本块的DAG的中间代码优化</h2><ul>\n<li>基本块：程序中一段顺序执行的语句序列</li>\n<li>通过每一条三地址码或四元式构建节点，将相关的节点相连，若节点内容一样，在右边加上名字，节点下方为常量值或运算符。</li>\n</ul>\n","text":"编译原理作业： 正则表达式生成NFA&#x2F;DFA LL1 词法分析 LR 词法分析 编译程序的功能组织结构图 ‘词法分析器→语法分析器→语义分析器→中间代...","permalink":"/post/编译原理考点","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"基础","slug":"基础","count":35,"path":"api/categories/基础.json"}],"tags":[{"name":"Review","slug":"Review","count":7,"path":"api/tags/Review.json"},{"name":"编译原理","slug":"编译原理","count":1,"path":"api/tags/编译原理.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A%EF%BC%9A\"><span class=\"toc-text\">编译原理作业：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84%E5%9B%BE\"><span class=\"toc-text\">编译程序的功能组织结构图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA-FA\"><span class=\"toc-text\">有穷自动机(FA)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95\"><span class=\"toc-text\">上下文无关文法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%EF%BC%88%E6%9C%80%E5%B7%A6%E6%8E%A8%E5%AF%BC%EF%BC%9A%E6%97%A2%E6%80%BB%E6%98%AF%E9%80%89%E6%8B%A9%E6%AF%8F%E4%B8%AA%E5%8F%A5%E5%9E%8B%E7%9A%84%E6%9C%80%E5%B7%A6%E9%9D%9E%E7%BB%88%E7%BB%93%E7%AC%A6%E8%BF%9B%E8%A1%8C%E6%9B%BF%E6%8D%A2%EF%BC%89\"><span class=\"toc-text\">自顶向下语法分析 （最左推导：既总是选择每个句型的最左非终结符进行替换）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90-%EF%BC%88%E5%BD%92%E7%BA%A6%EF%BC%89\"><span class=\"toc-text\">自底向上语法分析 （归约）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90\"><span class=\"toc-text\">语义分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E4%B8%89%E5%9C%B0%E5%9D%80%E7%A0%81%E7%9A%84%E5%9B%9B%E5%85%83%E5%BC%8F%E3%80%81%E4%B8%89%E5%85%83%E5%BC%8F%E8%A1%A8%E7%A4%BA\"><span class=\"toc-text\">中间代码三地址码的四元式、三元式表示</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E4%BA%8E%E5%9F%BA%E6%9C%AC%E5%9D%97%E7%9A%84DAG%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">基于基本块的DAG的中间代码优化</span></a></li></ol>","author":{"name":"ClaRn","slug":"blog-author","avatar":"/gallery/avatar.jpg","link":"/","description":"当你在浪费时间的事情里获得了快乐，那就不是在浪费时间。 ——罗素","socials":{"github":"https://github.com/iYIYiYIYi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"软件工程中的开发模型","uid":"cfd4ec52764f9243a80a5ef9b48d3349","slug":"软件工程","date":"2023-03-23T16:41:13.000Z","updated":"2023-12-06T14:51:26.098Z","comments":true,"path":"api/articles/软件工程.json","keywords":"记录, 学习, ClaRnS","cover":"/gallery/os.jpg","text":"软件开发生命周期（software development lifecycle (SDLC) ）软件的产生直到报废的生命周期，包括：问题定义、可行性分析、需求分...","permalink":"/post/软件工程","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"基础","slug":"基础","count":35,"path":"api/categories/基础.json"}],"tags":[{"name":"Review","slug":"Review","count":7,"path":"api/tags/Review.json"},{"name":"软件工程","slug":"软件工程","count":1,"path":"api/tags/软件工程.json"}],"author":{"name":"ClaRn","slug":"blog-author","avatar":"/gallery/avatar.jpg","link":"/","description":"当你在浪费时间的事情里获得了快乐，那就不是在浪费时间。 ——罗素","socials":{"github":"https://github.com/iYIYiYIYi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"进程管理","uid":"d655af595b90ac0e0949f931f50e7fe8","slug":"进程管理","date":"2022-04-24T12:42:46.000Z","updated":"2023-12-06T14:51:52.158Z","comments":true,"path":"api/articles/进程管理.json","keywords":"记录, 学习, ClaRnS","cover":"/gallery/os.jpg","text":"进程进程的概念和特征进程的概念从不同的角度看，进程可以有不同的定义，比较典型的是： 进程是程序的一次执行过程 进程是一个程序及其数据在处理机上顺序执行时所发生的...","permalink":"/post/进程管理","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"操作系统","slug":"操作系统","count":3,"path":"api/tags/操作系统.json"},{"name":"Review","slug":"Review","count":7,"path":"api/tags/Review.json"}],"author":{"name":"ClaRn","slug":"blog-author","avatar":"/gallery/avatar.jpg","link":"/","description":"当你在浪费时间的事情里获得了快乐，那就不是在浪费时间。 ——罗素","socials":{"github":"https://github.com/iYIYiYIYi","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}