{"title":"Smith-Waterman算法和Needleman-Wunsch算法","uid":"250cf64c9de21149319ed296b52cadd2","slug":"Smith-Waterman算法和Needleman-Wunsch算法","date":"2023-04-25T21:41:09.000Z","updated":"2023-11-17T03:38:18.448Z","comments":true,"path":"api/articles/Smith-Waterman算法和Needleman-Wunsch算法.json","keywords":"记录, 学习, ClaRnS","cover":[],"content":"<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\"></a> 简介</h2>\n<p>Smith-Waterman算法和Needleman-Wunsch算法都是生物信息学领域非常经典的算法，主要用于基因或者蛋白质序列的比对。</p>\n<p>Neeleman-Wunsch算法是基于生物信息学知识来匹配蛋白序列或者基因序列的算法，是将动态规划算法应用于生物序列的比较的早期实践之一。</p>\n<p>Smith-Waterman算法是Needleman-Wunsch算法的延伸，相比于Needleman算法主要聚焦于一整条序列的全局比对，Smith算法更多的用于找寻两个序列中具有高度相似度的片段。</p>\n<h2 id=\"needleman-wunsch算法原理\"><a class=\"markdownIt-Anchor\" href=\"#needleman-wunsch算法原理\"></a> Needleman-Wunsch算法原理</h2>\n<p>NW算法主要用于对比两个序列并得到这两个序列的全部序列匹配。</p>\n<p>假设两个待比对序列为：AAG 和 AGC ，且不同的碱基对应的分值如下表所示，空值的罚分为线性距离，值为-5 。</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>A</th>\n<th>C</th>\n<th>G</th>\n<th>T</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>2</td>\n<td>-7</td>\n<td>-5</td>\n<td>-7</td>\n</tr>\n<tr>\n<td>C</td>\n<td>-7</td>\n<td>2</td>\n<td>-7</td>\n<td>-5</td>\n</tr>\n<tr>\n<td>G</td>\n<td>-5</td>\n<td>-7</td>\n<td>2</td>\n<td>-7</td>\n</tr>\n<tr>\n<td>T</td>\n<td>-7</td>\n<td>-5</td>\n<td>-7</td>\n<td>2</td>\n</tr>\n</tbody>\n</table>\n<p>即DP矩阵中计算分数的公式为：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mspace linebreak=\"newline\"></mspace><mi>b</mi><mi>e</mi><mi>g</mi><mi>i</mi><mi>n</mi><mrow><mi>e</mi><mi>q</mi><mi>u</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn><mi mathvariant=\"normal\">，</mi><mspace linebreak=\"newline\"></mspace><mi>e</mi><mi>n</mi><mi>d</mi><mrow><mi>e</mi><mi>q</mi><mi>u</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\\\begin{equation}\nF(0,0)=0 ，\n\\\\end{equation}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">n</span></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord cjk_fallback\">，</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">d</span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">n</span></span></span></span></span></span></p>\n\\\\begin{equation}\nF(i,j)= max \n\\\\left \\\\{\n    \\begin{array}{lr}\n    F(i-1,j-1)+s(x_i, y_j), \\\\\\\\\n    F(i-1,j)+d, \\\\\\\\\n    F(i,j-1)+d, \\\\\\\\\n    \\end{array}\n\\\\right.\n\\\\end{equation}\n\n<p>计算所得结果如下图：<img src=\"/gallery/sw_algo_and_nw_algo/nw_result.png\" alt=\"推导结果\" /></p>\n<p>然后回溯得到对比结果： <img src=\"/gallery/sw_algo_and_nw_algo/reverse_result.png\" alt=\"回溯结果\" /></p>\n<p>关于回溯：在北大的生物信息学导论课程中并没有提及回溯的具体方式，不过可以参考下面这篇博客：<a href=\"https://blog.csdn.net/yohjob/article/details/89144032\">https://blog.csdn.net/yohjob/article/details/89144032</a></p>\n<h2 id=\"smith-waterman算法\"><a class=\"markdownIt-Anchor\" href=\"#smith-waterman算法\"></a> Smith-Waterman算法</h2>\n<p>Smith-Waterman算法与Needleman-Wunsch算法差别并不大，主要存在的差异是DP矩阵的计算公式，Smith-Waterman算法给公式的值规定了最小值从而突出局部特征。公式如下所示：</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mspace linebreak=\"newline\"></mspace><mi>b</mi><mi>e</mi><mi>g</mi><mi>i</mi><mi>n</mi><mrow><mi>e</mi><mi>q</mi><mi>u</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><mi>F</mi><mo stretchy=\"false\">(</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>0</mn><mo stretchy=\"false\">)</mo><mo>=</mo><mn>0</mn><mi mathvariant=\"normal\">，</mi><mspace linebreak=\"newline\"></mspace><mi>e</mi><mi>n</mi><mi>d</mi><mrow><mi>e</mi><mi>q</mi><mi>u</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></mrow><annotation encoding=\"application/x-tex\">\\\\begin{equation}\nF(0,0)=0 ，\n\\\\end{equation}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">b</span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">n</span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">n</span></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">F</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">0</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">0</span><span class=\"mord cjk_fallback\">，</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\">n</span><span class=\"mord mathdefault\">d</span><span class=\"mord\"><span class=\"mord mathdefault\">e</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathdefault\">u</span><span class=\"mord mathdefault\">a</span><span class=\"mord mathdefault\">t</span><span class=\"mord mathdefault\">i</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\">n</span></span></span></span></span></span></p>\n\\\\begin{equation}\nF(i,j)= max  \\\\left\\\\{\n    \\\\begin{array}{lr}\n    F(i-1,j-1)+s(x_i, y_j), \\\\\\\\\n    F(i-1,j)+d, \\\\\\\\\n    F(i,j-1)+d, \\\\\\\\\n    0 , \\\\\\\\\n    \\\\end{array}\n\\\\right.\n\\\\end{equation}\n\n","text":" 简介 Smith-Waterman算法和Needleman-Wunsch算法都是生物信息学领域非常经典的算法，主要用于基因或者蛋白质序列的比对。 Neelem...","permalink":"/post/Smith-Waterman算法和Needleman-Wunsch算法","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"生物信息学","slug":"生物信息学","count":2,"path":"api/categories/生物信息学.json"},{"name":"基础","slug":"生物信息学/基础","count":1,"path":"api/categories/生物信息学/基础.json"}],"tags":[{"name":"生物信息学","slug":"生物信息学","count":2,"path":"api/tags/生物信息学.json"},{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"},{"name":"动态规划","slug":"动态规划","count":1,"path":"api/tags/动态规划.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\"> 简介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#needleman-wunsch%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86\"><span class=\"toc-text\"> Needleman-Wunsch算法原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#smith-waterman%E7%AE%97%E6%B3%95\"><span class=\"toc-text\"> Smith-Waterman算法</span></a></li></ol>","author":{"name":"ClaRn","slug":"blog-author","avatar":"/gallery/avatar.jpg","link":"/","description":"当你在浪费时间的事情里获得了快乐，那就不是在浪费时间。 ——罗素","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"马尔可夫链和隐马尔可夫模型","uid":"80dc6c398842f9a2e7cabf21fa1c2234","slug":"马尔可夫链和n隐马尔可夫模型","date":"2023-04-26T04:16:47.000Z","updated":"2023-11-17T03:35:38.314Z","comments":true,"path":"api/articles/马尔可夫链和n隐马尔可夫模型.json","keywords":"记录, 学习, ClaRnS","cover":[],"text":" 马尔可夫性质 马尔可夫链是由一个条件分布来表示的P(Xn+1∣XN)P(X_{n+1}|X_N)P(Xn+1​∣XN​) ，这被称为随机过程中的转移概率。马尔...","permalink":"/post/马尔可夫链和n隐马尔可夫模型","photos":[],"count_time":{"symbolsCount":723,"symbolsTime":"1 mins."},"categories":[{"name":"生物信息学","slug":"生物信息学","count":2,"path":"api/categories/生物信息学.json"},{"name":"人工智能","slug":"生物信息学/人工智能","count":1,"path":"api/categories/生物信息学/人工智能.json"},{"name":"基础","slug":"生物信息学/人工智能/基础","count":1,"path":"api/categories/生物信息学/人工智能/基础.json"}],"tags":[{"name":"生物信息学","slug":"生物信息学","count":2,"path":"api/tags/生物信息学.json"},{"name":"算法","slug":"算法","count":2,"path":"api/tags/算法.json"},{"name":"人工智能","slug":"人工智能","count":1,"path":"api/tags/人工智能.json"}],"author":{"name":"ClaRn","slug":"blog-author","avatar":"/gallery/avatar.jpg","link":"/","description":"当你在浪费时间的事情里获得了快乐，那就不是在浪费时间。 ——罗素","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"图像特征","uid":"ffa3c8772fdf3309434ff546ef79c450","slug":"图像特征","date":"2023-04-02T13:09:32.000Z","updated":"2023-09-19T15:08:35.420Z","comments":true,"path":"api/articles/图像特征.json","keywords":"记录, 学习, ClaRnS","cover":null,"text":" SIFT、HOG特征 SIFT特征 Scale Invariant Feature Transform ，又称尺度不变特征变换。SIFT特征对旋转、尺度缩放、...","permalink":"/post/图像特征","photos":[],"count_time":{"symbolsCount":416,"symbolsTime":"1 mins."},"categories":[{"name":"图形图像","slug":"图形图像","count":1,"path":"api/categories/图形图像.json"}],"tags":[{"name":"图像处理","slug":"图像处理","count":1,"path":"api/tags/图像处理.json"},{"name":"OpenCV","slug":"OpenCV","count":1,"path":"api/tags/OpenCV.json"}],"author":{"name":"ClaRn","slug":"blog-author","avatar":"/gallery/avatar.jpg","link":"/","description":"当你在浪费时间的事情里获得了快乐，那就不是在浪费时间。 ——罗素","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}